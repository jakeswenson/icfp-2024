/*!

    DEC	OCT	HEX	BIN	Symbol	HTML Number	HTML Name	Description
    32 040	20	00100000	SP	&#32;	 	Space
    33 041	21	00100001	!	&#33;	&excl;	Exclamation mark
    34 042	22	00100010	"	&#34;	&quot;	Double quotes (or speech marks)
    35 043	23	00100011	#	&#35;	&num;	Number sign
    36 044	24	00100100	$	&#36;	&dollar;	Dollar
    37 045	25	00100101	%	&#37;	&percnt;	Per cent sign
    38 046	26	00100110	&	&#38;	&amp;	Ampersand
    39 047	27	00100111	'	&#39;	&apos;	Single quote
    40 050	28	00101000	(	&#40;	&lparen;	Open parenthesis (or open bracket)
    41 051	29	00101001	)	&#41;	&rparen;	Close parenthesis (or close bracket)
    42 052	2A	00101010	*	&#42;	&ast;	Asterisk
    43 053	2B	00101011	+	&#43;	&plus;	Plus
    44 054	2C	00101100	,	&#44;	&comma;	Comma
    45 055	2D	00101101	-	&#45;	 	Hyphen-minus
    46 056	2E	00101110	.	&#46;	&period;	Period, dot or full stop
    47 057	2F	00101111	/	&#47;	&sol;	Slash or divide
    48 060	30	00110000	0	&#48;	 	Zero
    49 061	31	00110001	1	&#49;	 	One
    50 062	32	00110010	2	&#50;	 	Two
    51 063	33	00110011	3	&#51;	 	Three
    52 064	34	00110100	4	&#52;	 	Four
    53 065	35	00110101	5	&#53;	 	Five
    54 066	36	00110110	6	&#54;	 	Six
    55 067	37	00110111	7	&#55;	 	Seven
    56 070	38	00111000	8	&#56;	 	Eight
    57 071	39	00111001	9	&#57;	 	Nine
    58 072	3A	00111010	:	&#58;	&colon;	Colon
    59 073	3B	00111011	;	&#59;	&semi;	Semicolon
    60 074	3C	00111100	<	&#60;	&lt;	Less than (or open angled bracket)
    61 075	3D	00111101	=	&#61;	&equals;	Equals
    62 076	3E	00111110	>	&#62;	&gt;	Greater than (or close angled bracket)
    63 077	3F	00111111	?	&#63;	&quest;	Question mark
    64 100	40	01000000	@	&#64;	&commat;	At sign
    65 101	41	01000001	A	&#65;	 	Uppercase A
    66 102	42	01000010	B	&#66;	 	Uppercase B
    67 103	43	01000011	C	&#67;	 	Uppercase C
    68 104	44	01000100	D	&#68;	 	Uppercase D
    69 105	45	01000101	E	&#69;	 	Uppercase E
    70 106	46	01000110	F	&#70;	 	Uppercase F
    71 107	47	01000111	G	&#71;	 	Uppercase G
    72 110	48	01001000	H	&#72;	 	Uppercase H
    73 111	49	01001001	I	&#73;	 	Uppercase I
    74 112	4A	01001010	J	&#74;	 	Uppercase J
    75 113	4B	01001011	K	&#75;	 	Uppercase K
    76 114	4C	01001100	L	&#76;	 	Uppercase L
    77 115	4D	01001101	M	&#77;	 	Uppercase M
    78 116	4E	01001110	N	&#78;	 	Uppercase N
    79 117	4F	01001111	O	&#79;	 	Uppercase O
    80 120	50	01010000	P	&#80;	 	Uppercase P
    81 121	51	01010001	Q	&#81;	 	Uppercase Q
    82 122	52	01010010	R	&#82;	 	Uppercase R
    83 123	53	01010011	S	&#83;	 	Uppercase S
    84 124	54	01010100	T	&#84;	 	Uppercase T
    85 125	55	01010101	U	&#85;	 	Uppercase U
    86 126	56	01010110	V	&#86;	 	Uppercase V
    87 127	57	01010111	W	&#87;	 	Uppercase W
    88 130	58	01011000	X	&#88;	 	Uppercase X
    89 131	59	01011001	Y	&#89;	 	Uppercase Y
    90 132	5A	01011010	Z	&#90;	 	Uppercase Z
    91 133	5B	01011011	`[`	&#91;	&lsqb;	Opening bracket
    92 134	5C	01011100	\	&#92;	&bsol;	Backslash
    93 135	5D	01011101	]	&#93;	&rsqb;	Closing bracket
    94 136	5E	01011110	^	&#94;	&Hat;	Caret - circumflex
    95 137	5F	01011111	_	&#95;	&lowbar;	Underscore
    96 140	60	01100000	`	&#96;	&grave;	Grave accent
    97 141	61	01100001	a	&#97;	 	Lowercase a
    98 142	62	01100010	b	&#98;	 	Lowercase b
    99 143	63	01100011	c	&#99;	 	Lowercase c
    100 144	64	01100100	d	&#100;	 	Lowercase d
    101 145	65	01100101	e	&#101;	 	Lowercase e
    102 146	66	01100110	f	&#102;	 	Lowercase f
    103 147	67	01100111	g	&#103;	 	Lowercase g
    104 150	68	01101000	h	&#104;	 	Lowercase h
    105 151	69	01101001	i	&#105;	 	Lowercase i
    106 152	6A	01101010	j	&#106;	 	Lowercase j
    107 153	6B	01101011	k	&#107;	 	Lowercase k
    108 154	6C	01101100	l	&#108;	 	Lowercase l
    109 155	6D	01101101	m	&#109;	 	Lowercase m
    110 156	6E	01101110	n	&#110;	 	Lowercase n
    111 157	6F	01101111	o	&#111;	 	Lowercase o
    112 160	70	01110000	p	&#112;	 	Lowercase p
    113 161	71	01110001	q	&#113;	 	Lowercase q
    114 162	72	01110010	r	&#114;	 	Lowercase r
    115 163	73	01110011	s	&#115;	 	Lowercase s
    116 164	74	01110100	t	&#116;	 	Lowercase t
    117 165	75	01110101	u	&#117;	 	Lowercase u
    118 166	76	01110110	v	&#118;	 	Lowercase v
    119 167	77	01110111	w	&#119;	 	Lowercase w
    120 170	78	01111000	x	&#120;	 	Lowercase x
    121 171	79	01111001	y	&#121;	 	Lowercase y
    122 172	7A	01111010	z	&#122;	 	Lowercase z
    123 173	7B	01111011	{	&#123;	&lcub;	Opening brace
    124 174	7C	01111100	|	&#124;	&verbar;	Vertical bar
    125 175	7D	01111101	}	&#125;	&rcub;	Closing brace
    126 176	7E	01111110	~	&#126;	&tilde;	Equivalency sign - tilde
*/
use color_eyre::eyre::anyhow;
use tracing::error;

const ALIEN_ASCII : &'static str = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`|~ \n";
const MIN_CHAR: char = '!'; // ASCII 33
const MAX_CHAR: char = '~'; // ASCII 126
const NUM_BASE: usize = 94;

type ExprRef = Box<ICFPExpr>;

/// ICFP Alien Language
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ICFPExpr {
  Boolean(Bool),
  Integer(Int),
  String(Str),
  UnaryOp(UnOp, ExprRef),
  BinaryOp(BinOp, ExprRef, ExprRef),
  /// ? B> I# I$ S9%3 S./
  If(ExprRef, ExprRef, ExprRef),
  /// B$ B$ L# L$ v# B. SB%,,/ S}Q/2,$_ IK
  /// ((\v2 -> \v3 -> v2) ("Hello" . " World!")) 42
  Lambda(Var, ExprRef),
  VarRef(Var),
  /// The above set of language constructs are all that researchers have discovered,
  /// and it is conjectured that the Cult will never use anything else in their
  /// communication towards Earth. However, it is unknown whether more language constructs exist.
  Unknown {
    indicator: char,
    body: String,
  },
}

/// As communication with Earth is complicated,
/// the Cult seems to have put some restrictions on their Macroware Insight software.
/// Specifically, message processing is aborted when exceeding 10_000_000 beta reductions.
/// Built-in operators are strict (except for B$, of course) and do not count
/// towards the limit of beta reductions. Contestants' messages therefore must stay within these limits.
///
/// For example, the following term, which evaluates to 16, uses 109 beta reductions during evaluation:
///
/// ```
/// B$ B$ L" B$ L# B$ v" B$ v# v# L# B$ v" B$ v# v# L" L# ? B= v# I! I" B$ L$ B+ B$ v" v$ B$ v" v$ B- v# I" I%
/// ```
///
/// Researchers expect that the limit on the amount beta reductions is the only limit that contestants may run into,
/// but there seem to also be some (unknown) limits on memory usage and total runtime.
const FUNCTION_CALL_LIMIT: usize = 1000;

#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
pub enum Bool {
  True,
  False,
}

#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug, Hash)]
pub struct Int(pub usize);

#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug, Hash)]
pub struct Var(pub usize);

#[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Debug, Hash)]
pub struct Str(pub String);

#[derive(Copy, Clone, Eq, PartialEq, Debug, Hash)]
pub enum UnOp {
  /// `-`	Integer negation	U- I$ -> -3
  Negate,
  /// `!`	Boolean not	U! T -> false
  Not,
  /// `#`	string-to-int: interpret a string as a base-94 number	U# S4%34 -> 15818151
  StrToInt,
  /// `$`	int-to-string: inverse of the above	U$ I4%34 -> test
  IntToStr,
}

#[derive(Copy, Clone, Eq, PartialEq, Debug, Hash)]
pub enum BinOp {
  /// `+`	Integer addition	B+ I# I$ -> 5
  Add,
  /// `-`	Integer subtraction	B- I$ I# -> 1
  Sub,
  /// `*`	Integer multiplication	B* I$ I# -> 6
  Mul,
  /// `/`	Integer division (truncated towards zero)	B/ U- I( I# -> -3
  Div,
  /// `%`	Integer modulo	B% U- I( I# -> -1
  Mod,
  /// `<`	Integer comparison	B< I$ I# -> false
  LessThan,
  /// `>`	Integer comparison	B> I$ I# -> true
  GreaterThan,
  /// `=`	Equality comparison, works for int, bool and string	B= I$ I# -> false
  Equals,
  /// `|`	Boolean or	B| T F -> true
  Or,
  /// `&`	Boolean and	B& T F -> false
  And,
  /// `.`	String concatenation	B. S4% S34 -> "test"
  Concat,
  /// `T`	Take first x chars of string y	BT I$ S4%34 -> "tes"
  TakeChars,
  /// `D`	Drop first x chars of string y	BD I$ S4%34 -> "t"
  SkipChars,
  /// `$` Apply term x to y (see ...)
  ApplyLambda,
}

pub trait Encode {
  fn encode(&self) -> String;
}

impl Encode for ICFPExpr {
  fn encode(&self) -> String {
    match self {
      ICFPExpr::Boolean(b) => b.encode(),
      ICFPExpr::Integer(i) => format!("I{}", i.encode()),
      ICFPExpr::String(s) => format!("S{}", s.encode()),
      ICFPExpr::UnaryOp(op, expr) => format!("U{} {}", op.encode(), expr.encode()),
      ICFPExpr::BinaryOp(op, left, right) => {
        format!("B{} {} {}", op.encode(), left.encode(), right.encode())
      }
      ICFPExpr::If(cond, if_true, if_false) => format!(
        "? {} {} {}",
        cond.encode(),
        if_true.encode(),
        if_false.encode()
      ),
      ICFPExpr::Lambda(arg, body) => format!("L{} {}", arg.encode(), body.encode()),
      ICFPExpr::VarRef(var) => format!("v{}", var.encode()),
      ICFPExpr::Unknown {
        indicator: _indicator,
        body: _body,
      } => unimplemented!(),
    }
  }
}

impl Encode for Bool {
  fn encode(&self) -> String {
    match self {
      Bool::True => "T".to_string(),
      Bool::False => "F".to_string(),
    }
  }
}

// How the fuck do you do negatives?
fn base94_encode_number(mut num: usize) -> String {
  let ascii_offset = 33; // '!' is ASCII 33
  let mut encoded = String::new();

  if num == 0 {
    return format!("{}", MIN_CHAR);
  }

  while num > 0 {
    let remainder = num % NUM_BASE;
    num /= NUM_BASE;
    encoded.push((remainder as u8 + ascii_offset) as char);
  }

  encoded.chars().rev().collect() // Reverse the encoded string
}

fn base94_decode(encoded: &str) -> color_eyre::Result<usize> {
  let ascii_offset = 33; // '!' is ASCII 33
  let mut num: usize = 0;

  for (i, char) in encoded.chars().rev().enumerate() {
    let value = (char as usize).checked_sub(ascii_offset);
    if let Some(digit) = value {
      if digit < NUM_BASE {
        num += digit * NUM_BASE.pow(i as u32);
      } else {
        return Err(anyhow!("Invalid character '{}' in input", char));
      }
    } else {
      return Err(anyhow!("Invalid character '{}' in input", char));
    }
  }

  Ok(num)
}

impl Encode for Int {
  fn encode(&self) -> String {
    base94_encode_number(self.0)
  }
}

impl Encode for Var {
  fn encode(&self) -> String {
    base94_encode_number(self.0)
  }
}

impl Encode for Str {
  fn encode(&self) -> String {
    self
      .0
      .chars()
      .map(|c| {
        let c_base = MIN_CHAR as usize;
        let encoded_idx = ALIEN_ASCII
          .char_indices()
          .find_map(|(idx, x)| if x == c { Some(idx) } else { None })
          .unwrap();
        (c_base + encoded_idx) as u8 as char
      })
      .collect::<String>()
  }
}

impl Encode for UnOp {
  fn encode(&self) -> String {
    let char = match self {
      UnOp::Negate => '-',
      UnOp::Not => '!',
      UnOp::StrToInt => '#',
      UnOp::IntToStr => '$',
    };
    format!("U{}", char)
  }
}

impl Encode for BinOp {
  fn encode(&self) -> String {
    "B".to_string()
  }
}

pub trait Decode: Sized {
  const OPERANDS: usize;
  fn decode(input: &str) -> color_eyre::Result<Self>;
}

impl Decode for ICFPExpr {
  const OPERANDS: usize = 0;

  fn decode(input: &str) -> color_eyre::Result<Self> {
    let mut expressions = input.split_whitespace();

    let Some(exp) = expressions.next() else {
      return Err(anyhow!("Not enough expressions in input: {input}"));
    };

    let indicator = &exp[0..1];
    let body = &exp[1..];

    let expr = match indicator {
      "S" => {
        let result = Str::decode(body)?;
        ICFPExpr::String(result)
      }
      "I" => ICFPExpr::Integer(Int::decode(body)?),
      "T" => ICFPExpr::Boolean(Bool::True),
      "F" => ICFPExpr::Boolean(Bool::False),
      "U" => todo!("Unary Ops"),
      "B" => todo!("Bin Ops"),
      "?" => todo!("Ifs"),
      "L" => todo!("Lambdas"),
      "v" => todo!("VarRef"),
      indicator => {
        error!(indicator, expr = exp, "Unsupported expression");
        return Err(anyhow!(
          "I don't know how to decode indicator {indicator} yet."
        ));
      }
    };

    Ok(expr)
  }
}

impl Decode for Str {
  const OPERANDS: usize = 0;

  fn decode(input: &str) -> color_eyre::Result<Self> {
    let string = input
      .chars()
      .map(|c| {
        let idx = c as usize - (MIN_CHAR as usize);
        ALIEN_ASCII.chars().nth(idx).unwrap()
      })
      .collect::<String>();

    Ok(Str(string))
  }
}

impl Decode for Int {
  const OPERANDS: usize = 0;

  fn decode(input: &str) -> color_eyre::Result<Self> {
    Ok(Int(base94_decode(input)?))
  }
}

impl Decode for Bool {
  const OPERANDS: usize = 0;

  fn decode(input: &str) -> color_eyre::Result<Self> {
    match input {
      "T" => Ok(Bool::True),
      "F" => Ok(Bool::False),
      c => Err(anyhow!("Unknown bool: {c}")),
    }
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use color_eyre::Result;

  #[test]
  fn encode_string() {
    let input = "Hello World!";
    let string = Str(input.to_string()).encode();

    let expected = "B%,,/}Q/2,$_";

    assert_eq!(string, expected);
  }

  #[test]
  fn decode_string() -> Result<()> {
    let input = "B%,,/}Q/2,$_";
    let expected = "Hello World!";

    let result = Str::decode(input)?;
    assert_eq!(result.0, expected);

    Ok(())
  }

  #[test]
  fn encode_num() {
    let string = Int(1337).encode();

    let expected = "/6";

    assert_eq!(string, expected);
  }

  #[test]
  fn decode_num() -> Result<()> {
    let input = "B%,,/}Q/2,$_";
    let expected = "Hello World!";

    let result = Str::decode(input)?;
    assert_eq!(result.0, expected);

    Ok(())
  }

  #[test]
  fn encode_bools() {
    assert_eq!(Bool::True.encode(), "T");
    assert_eq!(Bool::False.encode(), "F");
  }

  #[test]
  fn decode_bools() {
    assert_eq!(Bool::decode("T").unwrap(), Bool::True);
    assert_eq!(Bool::decode("F").unwrap(), Bool::False);
    assert!(Bool::decode("D").is_err());
  }
}
