/*!

    DEC	OCT	HEX	BIN	Symbol	HTML Number	HTML Name	Description
    32 040	20	00100000	SP	&#32;	 	Space
    33 041	21	00100001	!	&#33;	&excl;	Exclamation mark
    34 042	22	00100010	"	&#34;	&quot;	Double quotes (or speech marks)
    35 043	23	00100011	#	&#35;	&num;	Number sign
    36 044	24	00100100	$	&#36;	&dollar;	Dollar
    37 045	25	00100101	%	&#37;	&percnt;	Per cent sign
    38 046	26	00100110	&	&#38;	&amp;	Ampersand
    39 047	27	00100111	'	&#39;	&apos;	Single quote
    40 050	28	00101000	(	&#40;	&lparen;	Open parenthesis (or open bracket)
    41 051	29	00101001	)	&#41;	&rparen;	Close parenthesis (or close bracket)
    42 052	2A	00101010	*	&#42;	&ast;	Asterisk
    43 053	2B	00101011	+	&#43;	&plus;	Plus
    44 054	2C	00101100	,	&#44;	&comma;	Comma
    45 055	2D	00101101	-	&#45;	 	Hyphen-minus
    46 056	2E	00101110	.	&#46;	&period;	Period, dot or full stop
    47 057	2F	00101111	/	&#47;	&sol;	Slash or divide
    48 060	30	00110000	0	&#48;	 	Zero
    49 061	31	00110001	1	&#49;	 	One
    50 062	32	00110010	2	&#50;	 	Two
    51 063	33	00110011	3	&#51;	 	Three
    52 064	34	00110100	4	&#52;	 	Four
    53 065	35	00110101	5	&#53;	 	Five
    54 066	36	00110110	6	&#54;	 	Six
    55 067	37	00110111	7	&#55;	 	Seven
    56 070	38	00111000	8	&#56;	 	Eight
    57 071	39	00111001	9	&#57;	 	Nine
    58 072	3A	00111010	:	&#58;	&colon;	Colon
    59 073	3B	00111011	;	&#59;	&semi;	Semicolon
    60 074	3C	00111100	<	&#60;	&lt;	Less than (or open angled bracket)
    61 075	3D	00111101	=	&#61;	&equals;	Equals
    62 076	3E	00111110	>	&#62;	&gt;	Greater than (or close angled bracket)
    63 077	3F	00111111	?	&#63;	&quest;	Question mark
    64 100	40	01000000	@	&#64;	&commat;	At sign
    65 101	41	01000001	A	&#65;	 	Uppercase A
    66 102	42	01000010	B	&#66;	 	Uppercase B
    67 103	43	01000011	C	&#67;	 	Uppercase C
    68 104	44	01000100	D	&#68;	 	Uppercase D
    69 105	45	01000101	E	&#69;	 	Uppercase E
    70 106	46	01000110	F	&#70;	 	Uppercase F
    71 107	47	01000111	G	&#71;	 	Uppercase G
    72 110	48	01001000	H	&#72;	 	Uppercase H
    73 111	49	01001001	I	&#73;	 	Uppercase I
    74 112	4A	01001010	J	&#74;	 	Uppercase J
    75 113	4B	01001011	K	&#75;	 	Uppercase K
    76 114	4C	01001100	L	&#76;	 	Uppercase L
    77 115	4D	01001101	M	&#77;	 	Uppercase M
    78 116	4E	01001110	N	&#78;	 	Uppercase N
    79 117	4F	01001111	O	&#79;	 	Uppercase O
    80 120	50	01010000	P	&#80;	 	Uppercase P
    81 121	51	01010001	Q	&#81;	 	Uppercase Q
    82 122	52	01010010	R	&#82;	 	Uppercase R
    83 123	53	01010011	S	&#83;	 	Uppercase S
    84 124	54	01010100	T	&#84;	 	Uppercase T
    85 125	55	01010101	U	&#85;	 	Uppercase U
    86 126	56	01010110	V	&#86;	 	Uppercase V
    87 127	57	01010111	W	&#87;	 	Uppercase W
    88 130	58	01011000	X	&#88;	 	Uppercase X
    89 131	59	01011001	Y	&#89;	 	Uppercase Y
    90 132	5A	01011010	Z	&#90;	 	Uppercase Z
    91 133	5B	01011011	`[`	&#91;	&lsqb;	Opening bracket
    92 134	5C	01011100	\	&#92;	&bsol;	Backslash
    93 135	5D	01011101	]	&#93;	&rsqb;	Closing bracket
    94 136	5E	01011110	^	&#94;	&Hat;	Caret - circumflex
    95 137	5F	01011111	_	&#95;	&lowbar;	Underscore
    96 140	60	01100000	`	&#96;	&grave;	Grave accent
    97 141	61	01100001	a	&#97;	 	Lowercase a
    98 142	62	01100010	b	&#98;	 	Lowercase b
    99 143	63	01100011	c	&#99;	 	Lowercase c
    100 144	64	01100100	d	&#100;	 	Lowercase d
    101 145	65	01100101	e	&#101;	 	Lowercase e
    102 146	66	01100110	f	&#102;	 	Lowercase f
    103 147	67	01100111	g	&#103;	 	Lowercase g
    104 150	68	01101000	h	&#104;	 	Lowercase h
    105 151	69	01101001	i	&#105;	 	Lowercase i
    106 152	6A	01101010	j	&#106;	 	Lowercase j
    107 153	6B	01101011	k	&#107;	 	Lowercase k
    108 154	6C	01101100	l	&#108;	 	Lowercase l
    109 155	6D	01101101	m	&#109;	 	Lowercase m
    110 156	6E	01101110	n	&#110;	 	Lowercase n
    111 157	6F	01101111	o	&#111;	 	Lowercase o
    112 160	70	01110000	p	&#112;	 	Lowercase p
    113 161	71	01110001	q	&#113;	 	Lowercase q
    114 162	72	01110010	r	&#114;	 	Lowercase r
    115 163	73	01110011	s	&#115;	 	Lowercase s
    116 164	74	01110100	t	&#116;	 	Lowercase t
    117 165	75	01110101	u	&#117;	 	Lowercase u
    118 166	76	01110110	v	&#118;	 	Lowercase v
    119 167	77	01110111	w	&#119;	 	Lowercase w
    120 170	78	01111000	x	&#120;	 	Lowercase x
    121 171	79	01111001	y	&#121;	 	Lowercase y
    122 172	7A	01111010	z	&#122;	 	Lowercase z
    123 173	7B	01111011	{	&#123;	&lcub;	Opening brace
    124 174	7C	01111100	|	&#124;	&verbar;	Vertical bar
    125 175	7D	01111101	}	&#125;	&rcub;	Closing brace
    126 176	7E	01111110	~	&#126;	&tilde;	Equivalency sign - tilde
*/
use crate::evaluator::Environment;
use miette::{miette, LabeledSpan, Result};
use std::cell::OnceCell;
use std::fmt::{Debug, Formatter};
use std::str::SplitWhitespace;
use std::sync::atomic::{AtomicUsize, Ordering};
use tracing::warn;

const ALIEN_ASCII : &'static str = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`|~ \n";
const MIN_CHAR: char = '!'; // ASCII 33
const _MAX_CHAR: char = '~'; // ASCII 126
const NUM_BASE: NatType = 94;

pub type NatType = usize;

pub type ExprRef = Box<ICFPExpr>;

static LAMBDA_ID: AtomicUsize = AtomicUsize::new(0);

pub enum DeferredDecode<T> {
  Deferred {
    coded: String,
    lazy: OnceCell<Result<T>>,
  },
  Lit(T),
}

impl<T: Clone> DeferredDecode<T> {
  pub fn deferred(body: &str) -> Self {
    Self::Deferred {
      coded: body.to_string(),
      lazy: OnceCell::new(),
    }
  }
}

impl<T: Clone> Clone for DeferredDecode<T> {
  fn clone(&self) -> Self {
    match self {
      DeferredDecode::Deferred { coded, .. } => DeferredDecode::deferred(coded),
      DeferredDecode::Lit(i) => DeferredDecode::Lit(i.clone()),
    }
  }
}

impl<T: PartialEq> PartialEq for DeferredDecode<T> {
  fn eq(
    &self,
    other: &Self,
  ) -> bool {
    match (self, other) {
      (DeferredDecode::Deferred { coded, .. }, DeferredDecode::Deferred { coded: right, .. }) => {
        coded == right
      }
      (DeferredDecode::Lit(left), DeferredDecode::Lit(right)) => left == right,
      _ => false,
    }
  }
}

impl<T: Eq> Eq for DeferredDecode<T> {}

impl DeferredDecode<IntType> {
  pub fn decode(&self) -> Result<IntType> {
    match self {
      DeferredDecode::Deferred { coded, lazy } => {
        let res = lazy.get_or_init({
          let clone = coded.clone();
          move || base94_decode(&clone)
        });
        match res {
          Ok(i) => Ok(*i),
          Err(e) => Err(miette!("Failed to decode: {e:?}")),
        }
      }
      DeferredDecode::Lit(lit) => Ok(*lit),
    }
  }
}

impl DeferredDecode<String> {
  pub fn decode(&self) -> Result<&str> {
    match self {
      DeferredDecode::Deferred { coded, lazy } => {
        let res = lazy.get_or_init({
          let clone = coded.clone();
          move || String::decode(&clone)
        });
        match res {
          Ok(s) => Ok(&s),
          Err(e) => Err(miette!("Failed to decode: {e:?}")),
        }
      }
      DeferredDecode::Lit(lit) => Ok(lit),
    }
  }
}

impl Debug for DeferredDecode<IntType> {
  fn fmt(
    &self,
    f: &mut Formatter<'_>,
  ) -> std::fmt::Result {
    f.debug_tuple("Int")
      .field(match self {
        DeferredDecode::Deferred { coded, .. } => coded,
        DeferredDecode::Lit(lit) => lit,
      })
      .finish()
  }
}

impl Debug for DeferredDecode<String> {
  fn fmt(
    &self,
    f: &mut Formatter<'_>,
  ) -> std::fmt::Result {
    f.debug_tuple("String")
      .field(match self {
        DeferredDecode::Deferred { coded, .. } => coded,
        DeferredDecode::Lit(lit) => lit,
      })
      .finish()
  }
}

/// ICFP Alien Language
#[derive(Clone, Eq, PartialEq)]
pub enum ICFPExpr {
  Boolean(bool),
  Integer(DeferredDecode<IntType>),
  String(DeferredDecode<String>),
  UnaryOp(UnOp, ExprRef),
  BinaryOp(BinOp, ExprRef, ExprRef),
  /// ? B> I# I$ S9%3 S./
  If(ExprRef, ExprRef, ExprRef),
  /// B$ B$ L# L$ v# B. SB%,,/ S}Q/2,$_ IK
  /// ((\v2 -> \v3 -> v2) ("Hello" . " World!")) 42
  Lambda(usize, Var, ExprRef),
  VarRef(Var),
  Closure {
    id: usize,
    arg: Var,
    body: ExprRef,
    env: Environment,
  },
  /// The above set of language constructs are all that researchers have discovered,
  /// and it is conjectured that the Cult will never use anything else in their
  /// communication towards Earth. However, it is unknown whether more language constructs exist.
  Unknown {
    indicator: char,
    body: String,
  },
}

#[allow(dead_code)]
impl ICFPExpr {
  pub fn const_true() -> Self {
    ICFPExpr::Boolean(true)
  }

  pub fn const_false() -> Self {
    ICFPExpr::Boolean(false)
  }

  pub fn str<S: Into<String>>(str: S) -> Self {
    ICFPExpr::String(DeferredDecode::Lit(str.into()))
  }

  pub fn if_<C, T, F>(
    cond: C,
    if_true: T,
    if_false: F,
  ) -> Self
  where
    C: Into<ICFPExpr>,
    T: Into<ICFPExpr>,
    F: Into<ICFPExpr>,
  {
    ICFPExpr::If(
      Box::new(cond.into()),
      Box::new(if_true.into()),
      Box::new(if_false.into()),
    )
  }

  pub fn bin_op<L: Into<ICFPExpr>, R: Into<ICFPExpr>>(
    left: L,
    op: BinOp,
    right: R,
  ) -> Self {
    ICFPExpr::BinaryOp(op, Box::new(left.into()), Box::new(right.into()))
  }

  pub fn lambda(
    id: usize,
    arg: Var,
    body: ICFPExpr,
  ) -> Self {
    ICFPExpr::Lambda(id, arg, Box::new(body))
  }

  pub fn int(i: IntType) -> Self {
    ICFPExpr::Integer(DeferredDecode::Lit(i))
  }

  pub fn var(v: usize) -> Self {
    Self::VarRef(Var(v))
  }

  pub fn call<L: Into<ICFPExpr>, A: Into<ICFPExpr>>(
    lambda: L,
    arg: A,
  ) -> Self {
    Self::BinaryOp(
      BinOp::ApplyLambda,
      Box::new(lambda.into()),
      Box::new(arg.into()),
    )
  }
}

impl From<&str> for ICFPExpr {
  fn from(value: &str) -> Self {
    Self::str(value)
  }
}

impl From<String> for ICFPExpr {
  fn from(value: String) -> Self {
    Self::str(value)
  }
}

impl From<IntType> for ICFPExpr {
  fn from(value: IntType) -> Self {
    Self::Integer(DeferredDecode::Lit(value))
  }
}

impl From<Var> for ICFPExpr {
  fn from(value: Var) -> Self {
    Self::VarRef(value)
  }
}

impl From<bool> for ICFPExpr {
  fn from(value: bool) -> Self {
    Self::Boolean(value)
  }
}

impl<R: Into<ICFPExpr>> core::ops::Add<R> for ICFPExpr {
  type Output = ICFPExpr;

  fn add(
    self,
    rhs: R,
  ) -> Self::Output {
    ICFPExpr::bin_op(self, BinOp::Add, rhs.into())
  }
}

impl<R: Into<ICFPExpr>> core::ops::Sub<R> for ICFPExpr {
  type Output = ICFPExpr;

  fn sub(
    self,
    rhs: R,
  ) -> Self::Output {
    ICFPExpr::bin_op(self, BinOp::Sub, rhs.into())
  }
}

impl Debug for ICFPExpr {
  fn fmt(
    &self,
    f: &mut Formatter<'_>,
  ) -> std::fmt::Result {
    match self {
      ICFPExpr::Boolean(t) => write!(f, "{}", t),
      ICFPExpr::Integer(i) => write!(f, "{:?}", i),
      ICFPExpr::String(s) => write!(f, "{:?}", s),
      ICFPExpr::UnaryOp(op, operand) => match op {
        UnOp::Negate => write!(f, " -{:?} ", operand),
        UnOp::Not => write!(f, " !{:?} ", operand),
        UnOp::StrToInt => write!(f, " {:?}({:?}) ", op, operand),
        UnOp::IntToStr => write!(f, " {:?}({:?}) ", op, operand),
      },
      ICFPExpr::BinaryOp(op, left, right) => match op {
        BinOp::Add => write!(f, "({:?} + {:?})", left, right),
        BinOp::Sub => write!(f, "({:?} - {:?})", left, right),
        BinOp::Mul => write!(f, "({:?} * {:?})", left, right),
        BinOp::Div => write!(f, "({:?} / {:?})", left, right),
        BinOp::Mod => write!(f, "({:?} % {:?})", left, right),
        BinOp::LessThan => write!(f, "({:?} < {:?})", left, right),
        BinOp::GreaterThan => write!(f, "({:?} > {:?})", left, right),
        BinOp::Equals => write!(f, "({:?} == {:?})", left, right),
        BinOp::Or => write!(f, "({:?} || {:?})", left, right),
        BinOp::And => write!(f, "({:?} && {:?})", left, right),
        BinOp::Concat => write!(f, "({:?}).concat({:?})", left, right),
        BinOp::TakeChars => write!(f, "take({:?}, {:?})", left, right),
        BinOp::SkipChars => write!(f, "skip({:?}, {:?})", left, right),
        BinOp::ApplyLambda => write!(f, "{:?}({:?})", left, right),
      },
      ICFPExpr::If(cond, if_true, if_false) => {
        write!(
          f,
          "if ({:?}) {{ {:?} }} else {{ {:?} }}",
          cond, if_true, if_false
        )
      }
      ICFPExpr::Lambda(id, var, body) => write!(f, "function lam_{id}({:?}){{ {:?} }} ", var, body),
      ICFPExpr::VarRef(var) => write!(f, "{:?}", var),
      ICFPExpr::Closure { id, arg, body, env } => {
        write!(f, "Closure({id}) {:?} ({:?}) => {{ {:?} }}", env, arg, body)
      }
      ICFPExpr::Unknown { indicator, body } => f
        .debug_struct("Unknown")
        .field("indicator", indicator)
        .field("body", body)
        .finish(),
    }
  }
}

/// As communication with Earth is complicated,
/// the Cult seems to have put some restrictions on their Macroware Insight software.
/// Specifically, message processing is aborted when exceeding 10_000_000 beta reductions.
/// Built-in operators are strict (except for B$, of course) and do not count
/// towards the limit of beta reductions. Contestants' messages therefore must stay within these limits.
///
/// For example, the following term, which evaluates to 16, uses 109 beta reductions during evaluation:
///
/// ```
/// B$ B$ L" B$ L# B$ v" B$ v# v# L# B$ v" B$ v# v# L" L# ? B= v# I! I" B$ L$ B+ B$ v" v$ B$ v" v$ B- v# I" I%
/// ```
///
/// Researchers expect that the limit on the amount beta reductions is the only limit that contestants may run into,
/// but there seem to also be some (unknown) limits on memory usage and total runtime.
const _FUNCTION_CALL_LIMIT: usize = 1000;

pub type IntType = i64;

#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct Var(pub usize);

impl Debug for Var {
  fn fmt(
    &self,
    f: &mut Formatter<'_>,
  ) -> std::fmt::Result {
    write!(f, "v_{}", self.0)
  }
}

#[derive(Copy, Clone, Eq, PartialEq, Debug, Hash)]
pub enum UnOp {
  /// `-`	Integer negation	U- I$ -> -3
  Negate,
  /// `!`	Boolean not	U! T -> false
  Not,
  /// `#`	string-to-int: interpret a string as a base-94 number	U# S4%34 -> 15818151
  StrToInt,
  /// `$`	int-to-string: inverse of the above	U$ I4%34 -> test
  IntToStr,
}

#[derive(Copy, Clone, Eq, PartialEq, Debug, Hash)]
pub enum BinOp {
  /// `+`	Integer addition	B+ I# I$ -> 5
  Add,
  /// `-`	Integer subtraction	B- I$ I# -> 1
  Sub,
  /// `*`	Integer multiplication	B* I$ I# -> 6
  Mul,
  /// `/`	Integer division (truncated towards zero)	B/ U- I( I# -> -3
  Div,
  /// `%`	Integer modulo	B% U- I( I# -> -1
  Mod,
  /// `<`	Integer comparison	B< I$ I# -> false
  LessThan,
  /// `>`	Integer comparison	B> I$ I# -> true
  GreaterThan,
  /// `=`	Equality comparison, works for int, bool and string	B= I$ I# -> false
  Equals,
  /// `|`	Boolean or	B| T F -> true
  Or,
  /// `&`	Boolean and	B& T F -> false
  And,
  /// `.`	String concatenation	B. S4% S34 -> "test"
  Concat,
  /// `T`	Take first x chars of string y	BT I$ S4%34 -> "tes"
  TakeChars,
  /// `D`	Drop first x chars of string y	BD I$ S4%34 -> "t"
  SkipChars,
  /// `$` Apply term x to y (see ...)
  ApplyLambda,
}

pub trait Encode {
  fn encode(&self) -> String;
}

impl Encode for ICFPExpr {
  fn encode(&self) -> String {
    match self {
      ICFPExpr::Boolean(b) => b.encode(),
      ICFPExpr::Integer(i) => format!("I{}", i.encode()),
      ICFPExpr::String(s) => format!("S{}", s.encode()),
      ICFPExpr::UnaryOp(op, expr) => format!("U{} {}", op.encode(), expr.encode()),
      ICFPExpr::BinaryOp(op, left, right) => {
        format!("B{} {} {}", op.encode(), left.encode(), right.encode())
      }
      ICFPExpr::If(cond, if_true, if_false) => format!(
        "? {} {} {}",
        cond.encode(),
        if_true.encode(),
        if_false.encode()
      ),
      ICFPExpr::Lambda(_id, arg, body) => format!("L{} {}", arg.encode(), body.encode()),
      ICFPExpr::VarRef(var) => format!("v{}", var.encode()),
      ICFPExpr::Unknown {
        indicator: _indicator,
        body: _body,
      } => unimplemented!(),
      ICFPExpr::Closure { .. } => {
        unreachable!("You can't encode a closure")
      }
    }
  }
}

impl Encode for bool {
  fn encode(&self) -> String {
    if *self {
      "T".to_string()
    } else {
      "F".to_string()
    }
  }
}

// How the fuck do you do negatives?
pub fn base94_encode_number(mut num: NatType) -> String {
  let ascii_offset = 33; // '!' is ASCII 33
  let mut encoded = String::new();

  if num == 0 {
    return format!("{}", MIN_CHAR);
  }

  while num > 0 {
    let remainder = num % NUM_BASE;
    num /= NUM_BASE;
    encoded.push((remainder as u8 + ascii_offset) as char);
  }

  encoded.chars().rev().collect() // Reverse the encoded string
}

pub fn base94_decode(encoded: &str) -> Result<IntType> {
  let ascii_offset = 33; // '!' is ASCII 33
  let mut num: NatType = 0;

  for (i, char) in encoded.chars().rev().enumerate() {
    let value = (char as NatType).checked_sub(ascii_offset);
    if let Some(digit) = value {
      if digit < NUM_BASE {
        println!("{i}");
        let pow = NUM_BASE.pow(i as u32);
        println!("digit: {digit}, pow: {pow}");
        num += digit
          .checked_mul(pow)
          .ok_or(miette!("Encoded Number is too big: {encoded}"))?;
      } else {
        return Err(miette!(
          labels = vec![LabeledSpan::at(i..i + 1, "invalid"),],
          "Invalid character '{}' in input",
          char
        ));
      }
    } else {
      return Err(miette!(
        labels = vec![LabeledSpan::at(i..i + 1, "invalid"),],
        "Invalid character '{}' in input",
        char
      ));
    }
  }

  Ok(num as IntType)
}

impl Encode for DeferredDecode<String> {
  fn encode(&self) -> String {
    match self {
      DeferredDecode::Deferred { coded, .. } => format!("S{coded}"),
      DeferredDecode::Lit(s) => s.encode(),
    }
  }
}

impl Encode for DeferredDecode<IntType> {
  fn encode(&self) -> String {
    match self {
      DeferredDecode::Deferred { coded, .. } => format!("I{coded}"),
      DeferredDecode::Lit(s) => s.encode(),
    }
  }
}

impl Encode for IntType {
  fn encode(&self) -> String {
    base94_encode_number(*self as NatType)
  }
}

impl Encode for Var {
  fn encode(&self) -> String {
    base94_encode_number(self.0 as NatType)
  }
}

impl Encode for String {
  fn encode(&self) -> String {
    self
      .chars()
      .map(|c| {
        let c_base = MIN_CHAR as usize;
        let encoded_idx = ALIEN_ASCII
          .char_indices()
          .find_map(|(idx, x)| if x == c { Some(idx) } else { None })
          .unwrap();
        (c_base + encoded_idx) as u8 as char
      })
      .collect::<String>()
  }
}

impl Encode for UnOp {
  fn encode(&self) -> String {
    let char = match self {
      UnOp::Negate => '-',
      UnOp::Not => '!',
      UnOp::StrToInt => '#',
      UnOp::IntToStr => '$',
    };
    format!("{}", char)
  }
}

impl Encode for BinOp {
  fn encode(&self) -> String {
    "".to_string()
  }
}

pub trait Parsable: Sized {
  fn parse(input: &str) -> Result<Self> {
    Self::parse_impl(&mut input.split_whitespace())
  }

  fn parse_impl(input: &mut SplitWhitespace) -> Result<Self>;
}

impl Parsable for ICFPExpr {
  fn parse_impl(expressions: &mut SplitWhitespace) -> Result<Self> {
    let Some(exp) = expressions.next() else {
      return Err(miette!("Not enough expressions in input"));
    };

    let indicator = exp[0..1].chars().next().unwrap();
    let body = &exp[1..];

    let expr = match indicator {
      'S' => {
        let result = String::decode(body)?;
        ICFPExpr::str(result)
      }
      'I' => ICFPExpr::Integer(DeferredDecode::deferred(body)),
      'v' => ICFPExpr::VarRef(Var::decode(body)?),
      'T' => ICFPExpr::Boolean(true),
      'F' => ICFPExpr::Boolean(false),
      'U' => ICFPExpr::UnaryOp(
        UnOp::decode(body)?,
        Box::new(ICFPExpr::parse_impl(expressions)?),
      ),
      'B' => ICFPExpr::BinaryOp(
        BinOp::decode(body)?,
        Box::new(ICFPExpr::parse_impl(expressions)?),
        Box::new(ICFPExpr::parse_impl(expressions)?),
      ),
      '?' => ICFPExpr::If(
        Box::new(ICFPExpr::parse_impl(expressions)?),
        Box::new(ICFPExpr::parse_impl(expressions)?),
        Box::new(ICFPExpr::parse_impl(expressions)?),
      ),
      'L' => {
        let arg_name = Var::decode(body)?;
        ICFPExpr::Lambda(
          LAMBDA_ID.fetch_add(1, Ordering::SeqCst),
          arg_name,
          Box::new(ICFPExpr::parse_impl(expressions)?),
        )
      }
      indicator => {
        warn!(?indicator, expr = exp, "Unknown expression");
        ICFPExpr::Unknown {
          indicator,
          body: body.to_string(),
        }
      }
    };

    Ok(expr)
  }
}

pub trait Decode: Sized {
  fn decode(input: &str) -> Result<Self>;
}

impl Decode for String {
  fn decode(input: &str) -> Result<Self> {
    let result = input
      .chars()
      .map(|c| {
        let idx = c as usize - (MIN_CHAR as usize);
        ALIEN_ASCII.chars().nth(idx).unwrap()
      })
      .collect::<String>();

    Ok(result)
  }
}

impl Decode for IntType {
  fn decode(input: &str) -> Result<Self> {
    Ok(base94_decode(input)?)
  }
}

impl Decode for Var {
  fn decode(input: &str) -> Result<Self> {
    Ok(Var(base94_decode(input)? as usize))
  }
}

impl Decode for bool {
  fn decode(input: &str) -> Result<Self> {
    match input {
      "T" => Ok(true),
      "F" => Ok(false),
      c => Err(miette!("Unknown bool: {c}")),
    }
  }
}

impl Decode for UnOp {
  fn decode(input: &str) -> Result<Self> {
    let op = match input {
      "-" => UnOp::Negate,
      "!" => UnOp::Not,
      "#" => UnOp::StrToInt,
      "$" => UnOp::IntToStr,
      _ => return Err(miette!("Unknown unary operator: {input}")),
    };

    Ok(op)
  }
}

impl Decode for BinOp {
  fn decode(input: &str) -> Result<BinOp> {
    let op = match input {
      "+" => BinOp::Add,
      "-" => BinOp::Sub,
      "*" => BinOp::Mul,
      "/" => BinOp::Div,
      "%" => BinOp::Mod,
      "<" => BinOp::LessThan,
      ">" => BinOp::GreaterThan,
      "=" => BinOp::Equals,
      "|" => BinOp::Or,
      "&" => BinOp::And,
      "." => BinOp::Concat,
      "T" => BinOp::TakeChars,
      "D" => BinOp::SkipChars,
      "$" => BinOp::ApplyLambda,
      _ => return Err(miette!("Unknown binary operator: {input}")),
    };

    Ok(op)
  }
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn encode_string() {
    let input = "Hello World!";
    let string = input.to_string().encode();

    let expected = "B%,,/}Q/2,$_";

    assert_eq!(string, expected);
  }

  #[test]
  fn decode_string() -> Result<()> {
    let input = "B%,,/}Q/2,$_";
    let expected = "Hello World!";

    let result = String::decode(input)?;
    assert_eq!(result, expected);

    Ok(())
  }

  #[test]
  fn decode_unop() -> Result<()> {
    let input = "-";
    let expected = UnOp::Negate;
    let result = UnOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "!";
    let expected = UnOp::Not;
    let result = UnOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "#";
    let expected = UnOp::StrToInt;
    let result = UnOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "$";
    let expected = UnOp::IntToStr;
    let result = UnOp::decode(input)?;
    assert_eq!(result, expected);

    Ok(())
  }

  #[test]
  fn decode_binop() -> Result<()> {
    let input = "+";
    let expected = BinOp::Add;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "-";
    let expected = BinOp::Sub;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "*";
    let expected = BinOp::Mul;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "/";
    let expected = BinOp::Div;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "%";
    let expected = BinOp::Mod;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "<";
    let expected = BinOp::LessThan;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = ">";
    let expected = BinOp::GreaterThan;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "=";
    let expected = BinOp::Equals;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "|";
    let expected = BinOp::Or;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "&";
    let expected = BinOp::And;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = ".";
    let expected = BinOp::Concat;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "T";
    let expected = BinOp::TakeChars;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "D";
    let expected = BinOp::SkipChars;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "$";
    let expected = BinOp::ApplyLambda;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    Ok(())
  }

  #[test]
  fn encode_num() {
    let string = 1337.encode();

    let expected = "/6";

    assert_eq!(string, expected);
  }

  #[test]
  fn decode_num() -> Result<()> {
    let input = "B%,,/}Q/2,$_";
    let expected = "Hello World!";

    let result = String::decode(input)?;
    assert_eq!(result, expected);

    Ok(())
  }

  #[test]
  fn encode_bools() {
    assert_eq!(true.encode(), "T");
    assert_eq!(false.encode(), "F");
  }

  #[test]
  fn decode_bools() {
    assert_eq!(bool::decode("T").unwrap(), true);
    assert_eq!(bool::decode("F").unwrap(), false);
    assert!(bool::decode("D").is_err());
  }

  #[test]
  fn encode_if() {
    let expr = ICFPExpr::if_(ICFPExpr::const_true(), ICFPExpr::int(3), ICFPExpr::int(4));
    assert_eq!(expr.encode(), "? T I$ I%");
  }

  #[test]
  fn decode_if() -> Result<()> {
    let input = "? T I$ I%";
    let expected = ICFPExpr::if_(ICFPExpr::const_true(), ICFPExpr::int(3), ICFPExpr::int(4));

    let result = ICFPExpr::parse(input)?;
    assert_eq!(result, expected);

    Ok(())
  }

  #[test]
  fn encode_simple_lambda() {
    let expr = ICFPExpr::lambda(0, Var(1), ICFPExpr::int(3));
    assert_eq!(expr.encode(), "L\" I$");
  }

  #[test]
  fn decode_simple_lambda() -> Result<()> {
    let input = "L% I$";
    let expected = ICFPExpr::lambda(0, Var(4), ICFPExpr::int(3));
    let result = ICFPExpr::parse(input)?;
    assert_eq!(result, expected);

    Ok(())
  }
}
